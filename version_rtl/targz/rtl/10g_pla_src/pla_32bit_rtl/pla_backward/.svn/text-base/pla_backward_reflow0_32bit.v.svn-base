//FILE_HEADER-----------------------------------------------------------------
//ZTE  Copyright (C)
//ZTE Company Confidential
//----------------------------------------------------------------------------
//Project Name : RCUC PLA
//FILE NAME    : pla_backward_slice_cycle_ddr.v
//AUTHOR       : 
//Department   : 
//Email        : 
//----------------------------------------------------------------------------
//Module Hiberarchy :
//x                             |--
//x                             |--
//x pla_backward_reflow_32bit-- |--
//x                             |--U1_pla_id_seq_chk
//----------------------------------------------------------------------------
`timescale 1ns/100ps
module pla_backward_reflow0_32bit(
input               I_pla_312m5_clk            ,
input               I_pla_rst                  ,
input               I_cnt_clear                ,
input     [15:0]    I_pla_slice_id_depth_set   ,
input     [14:0]    I_pla_slice_id_new         ,
input               I_pla_slice_id_new_valid   ,
input     [14:0]    I_pla_slice_id_max         ,
input     [14:0]    I_pla_slice_id_min         ,
input               I_pla_slice_rd_resp        ,
input     [31:0]    I_pla_slice_rdata          ,
input               I_pla_reflow_fifo_rd       ,
output              O_pla_slice_rd_req         ,
output    [14:0]    O_pla_slice_rd_id          ,
output              O_pla_slice_data_rd        ,

output    [32:0]    O_pla_reflow_fifo_rdata    ,
output              O_pla_reflow_fifo_empty    ,
output reg   [31:0] O_pla_reflow_rderr_cnt     ,
output       [47:0] O_pla_reflow_id_wl         ,

output      [15:0]  O_reflow_55D5_cnt          ,
output      [15:0]  O_reflow_lose_cnt          ,
output              O_reflow_lose_reg          , 

output              O_pla_slice_id_depth_alful
);

parameter           C_REFLOW_IDLE                = 2'b00,
                    C_REFLOW_CATCH               = 2'b01,
                    C_REFLOW_READ                = 2'b10;
(*mark_debug ="true"*)reg       [1:0]     S_reflow_state                      ;
reg       [1:0]     S_reflow_state_next                 ;
(*mark_debug ="true"*)reg       [14:0]    S_slice_id_current           = 15'd0;
reg       [14:0]    S1_slice_id_current          = 15'd0;
reg                 S_slice_current_valid        = 1'b0 ;
reg       [10:0]    S_read_state_cnt             = 11'd0;
(*mark_debug ="true"*)reg                 S_reflow_idle_flg            = 1'b0 ;
reg                 S1_reflow_idle_flg           = 1'b0 ;
reg                 S2_reflow_idle_flg           = 1'b0 ;
(*mark_debug ="true"*)reg       [1:0]     S_reflow_catch_flg           = 2'b0 ;
reg                 S1_reflow_catch_flg          = 1'b0 ;
(*mark_debug ="true"*)reg                 S2_reflow_catch_flg          = 1'b0 ;
reg                 S_reflow_catch_add           = 1'b0 ;
reg                 S1_reflow_catch_add       = 1'b0 ;
reg                 S_pla_slice_rd_resp_buf      = 1'b0 ;
reg                 S_pla_slice_loss_flg         = 1'b0 ;
reg       [14:0]    S_slice_valid_ram_wr_addr    = 15'd0;
reg                 S_slice_valid_ram_wr_data    = 1'b0 ;
reg                 S_slice_valid_ram_wr         = 1'b0 ;
wire                S_slice_valid_ram_rd_data           ;
reg                 S_slice_valid_ram_col        = 1'b0 ;
reg                 S_slice_valid_ram_col_buf    = 1'b0 ;
reg                 S_slice_valid_ram_col_data   = 1'b0 ;
reg                 S_pla_slice_rd_req           = 1'b0 ;
reg                 S_pla_slice_rd_req_buf       = 1'b0 ;
reg       [14:0]    S_pla_slice_rd_id            = 15'd0;
reg                 S_pla_slice_data_rd          = 1'b0 ;
reg                 S_pla_slice_data_rd_buf1     = 1'b0 ;
reg                 S_pla_slice_data_rd_buf2     = 1'b0 ;
reg       [31:0]    S_pla_slice_rdata_buf        = 32'd0;
reg                 S_pla_slice_id_new_valid_buf = 1'b0 ;
reg       [32:0]    S_pla_reflow_fifo_wdata      = 32'b0;
reg                 S_pla_reflow_fifo_wr         = 1'b0 ;
wire      [9:0]     S_pla_reflow_fifo_usedw             ;
reg       [9:0]     S_pla_reflow_fifo_usedw_buf  = 10'd0;
reg                 S_pla_reflow_fifo_alful      = 1'b0 ;
reg                 S1_pla_reflow_fifo_alful     = 1'b0 ;
reg       [5:0]     S_pla_slice_data_rd_cnt      = 6'h3f;
reg                 S_pla_slice_id_depth_flg     = 1'b0 ;
reg       [15:0]    S_pla_reflow_id_wl           = 16'd0;
reg                 S_pla_slice_id_depth_alful   = 1'b0 ;
reg                 S_reflow_rderr_flag;
reg                 S_pla_reflow_fifo_rd       ;
reg     [32:0]      O1_pla_reflow_fifo_rdata    ;

////test
//// (*mark_debug ="true"*)reg   [14:0]    Ix_pla_slice_id_new         ;
//// (*mark_debug ="true"*)reg             Ix_pla_slice_id_new_valid   ;
//// (*mark_debug ="true"*)reg   [14:0]    Ix_pla_slice_id_max         ;
//// (*mark_debug ="true"*)reg   [14:0]    Ix_pla_slice_id_min         ;
//// (*mark_debug ="true"*)reg             Ix_pla_slice_rd_resp        ;
//// (*mark_debug ="true"*)reg             Ox_pla_slice_rd_req         ;
//// (*mark_debug ="true"*)reg   [14:0]    Ox_pla_slice_rd_id          ;
//// (*mark_debug ="true"*)reg             Ox_pla_slice_data_rd        ;

//// (*mark_debug ="true"*)reg             Ox_pla_reflow_fifo_empty    ;
//// 
//// 
//// always @ (posedge I_pla_312m5_clk )
//// begin
////     Ix_pla_slice_id_new        <= I_pla_slice_id_new         ;   
////     Ix_pla_slice_id_new_valid  <= I_pla_slice_id_new_valid   ;
////     Ix_pla_slice_id_max        <= I_pla_slice_id_max         ;
////     Ix_pla_slice_id_min        <= I_pla_slice_id_min         ;
////     Ix_pla_slice_rd_resp       <= I_pla_slice_rd_resp        ;

////     Ox_pla_slice_rd_req        <= O_pla_slice_rd_req         ;
////     Ox_pla_slice_rd_id         <= O_pla_slice_rd_id          ;
////     Ox_pla_slice_data_rd       <= O_pla_slice_data_rd        ;

////     Ox_pla_reflow_fifo_empty   <= O_pla_reflow_fifo_empty    ;
//// end
always @ (posedge I_pla_312m5_clk or posedge I_pla_rst)
begin
    if(I_pla_rst)
    begin
        O_pla_reflow_rderr_cnt[15:0] <= 16'd0;
        S_reflow_rderr_flag <= 1'b0;
    end
    else if(I_cnt_clear) 
    begin
        O_pla_reflow_rderr_cnt[15:0] <= 16'd0;
        S_reflow_rderr_flag <= 1'b0;
    end
    else if (S_read_state_cnt == 11'h7fe)
    begin
        O_pla_reflow_rderr_cnt[15:0]  <= O_pla_reflow_rderr_cnt[15:0] +16'd1;
        S_reflow_rderr_flag <= 1'b1;
    end
    else 
    begin
        S_reflow_rderr_flag <= 1'b0;
    end
end

always @ (posedge I_pla_312m5_clk or posedge I_pla_rst)
begin
    if(I_pla_rst)
        begin
            S_reflow_idle_flg <= 1'b0;
        end
    else if(S_slice_id_current == (I_pla_slice_id_max + 12'd1))
        begin
            S_reflow_idle_flg <= 1'b1;
        end
    else
        begin
            S_reflow_idle_flg <= 1'b0;
        end
end

always @ (posedge I_pla_312m5_clk)
begin
    S1_reflow_idle_flg <= S_reflow_idle_flg     ;
    S2_reflow_idle_flg <= S1_reflow_idle_flg;
end

always @ (posedge I_pla_312m5_clk or posedge I_pla_rst)
begin
    if(I_pla_rst)
        begin
        S_reflow_catch_flg <= 2'b00;
        end
    else if((I_pla_slice_id_min[14:13] == 2'b11) && (I_pla_slice_id_max[14:13] == 2'b00))
        begin
        if((S_slice_id_current[14:13] == 2'b00) && (S_slice_id_current > (I_pla_slice_id_max + 12'd1)))
                begin
                S_reflow_catch_flg <= 2'b10;
                end
        else if((S_slice_id_current[14:13] == 2'b11) && (S_slice_id_current < I_pla_slice_id_min ))
                begin
                S_reflow_catch_flg <= 2'b01;
                end
            else
                begin
                S_reflow_catch_flg <= 2'b00;
            end
                end
    else if (S_slice_id_current < I_pla_slice_id_min)
    begin
        S_reflow_catch_flg <= 2'b01;
        end
    else if (S_slice_id_current >= (I_pla_slice_id_max + 12'd2))
        begin
        S_reflow_catch_flg <= 2'b10;
        end
    else
        begin
        S_reflow_catch_flg <= 2'b00;
        end
end

always @ (posedge I_pla_312m5_clk or posedge I_pla_rst)
begin
    if(I_pla_rst)
        begin
        S1_reflow_catch_flg <= 1'b0;
        S2_reflow_catch_flg <= 1'b0;
        end
    else
        begin
        S1_reflow_catch_flg <= S_reflow_catch_flg[0] | S_reflow_catch_flg[1];
        S2_reflow_catch_flg <= S1_reflow_catch_flg;
        end
end

always @ (posedge I_pla_312m5_clk) ///由于ram输出延迟，id每两个clk 加1
begin
    if(S_reflow_state == C_REFLOW_CATCH)
        begin
            S_reflow_catch_add <= ~S_reflow_catch_add;
        end
    else
        begin
            S_reflow_catch_add <= 1'b0;
        end
end

always @ (posedge I_pla_312m5_clk)
begin
    S1_reflow_catch_add <= S_reflow_catch_add;
end

always @ (posedge I_pla_312m5_clk)
begin
    S_pla_slice_rd_resp_buf <= I_pla_slice_rd_resp;
end

always @ (posedge I_pla_312m5_clk or posedge I_pla_rst)
begin
    if(I_pla_rst)
        begin
            S_reflow_state <= C_REFLOW_IDLE;
        end
    else
        begin
            S_reflow_state <= S_reflow_state_next;
        end
end

always @ (*)
begin
    case(S_reflow_state)
        C_REFLOW_IDLE  :
        begin
            if(S_slice_current_valid && !S_pla_reflow_fifo_alful)
                begin
                    S_reflow_state_next = C_REFLOW_READ;
                end
            else if(S2_reflow_catch_flg && !S_reflow_idle_flg && !S2_reflow_idle_flg)
                begin
                    S_reflow_state_next = C_REFLOW_CATCH;
                end
            else
                begin
                    S_reflow_state_next = C_REFLOW_IDLE;
                end
        end
        C_REFLOW_CATCH :
        begin
            if(S_slice_current_valid && !S_pla_reflow_fifo_alful && !S_reflow_catch_add)
                begin
                    S_reflow_state_next = C_REFLOW_READ;
                end
            else if(S2_reflow_catch_flg)
                begin
                    S_reflow_state_next = C_REFLOW_CATCH;
                end
            else
                begin
                    S_reflow_state_next = C_REFLOW_IDLE;
                end
        end
        C_REFLOW_READ  :  ///启动计数
        begin
            if(S_read_state_cnt == 11'h7ff)   ///应该为0x7f，设定0x80是为了保护时序--dont wait,improve delay
            begin
                S_reflow_state_next = C_REFLOW_IDLE;
            end
            else if(I_pla_slice_rd_resp && !S_pla_slice_rd_resp_buf)
                begin
                    S_reflow_state_next = C_REFLOW_IDLE;
                end
            else
                begin
                    S_reflow_state_next = C_REFLOW_READ;
                end
        end
        default : S_reflow_state_next = C_REFLOW_IDLE;
    endcase
end

always @ (posedge I_pla_312m5_clk or posedge I_pla_rst)
begin
    if(I_pla_rst)
        begin
            S_slice_id_current <= 15'd0;
            S_read_state_cnt <= 11'd0;
        end
    else
        begin
            case(S_reflow_state)
                C_REFLOW_IDLE  :
                begin
                    S_read_state_cnt <= 11'd0;
                    if(S_slice_current_valid && !S_pla_reflow_fifo_alful)
                        begin
                            S_slice_id_current <= S_slice_id_current + 15'd1;
                        end
                    else
                        begin
                            S_slice_id_current <= S_slice_id_current;
                        end
                end
                C_REFLOW_CATCH :
                begin
                    S_read_state_cnt <= 11'd0;
                    if(S_reflow_catch_add)  //判断出vaild有效时，已经进行+1操作
                        begin
                            if(S_pla_reflow_fifo_alful || (!S_pla_reflow_fifo_alful && S1_pla_reflow_fifo_alful))
                                begin
                                    S_slice_id_current <= S_slice_id_current;
                                end
                           /// else if (S_reflow_catch_flg[0])
                           /// begin
                           ///     S_slice_id_current <= I_pla_slice_id_min;   ///要把小于MIN的值全部清0-----有问题。
                           /// end
                            else if(!S_slice_valid_ram_rd_data)
                            begin
                                    S_slice_id_current <= S_slice_id_current + 15'd1;
                                end
                        end
                    else if(S_slice_current_valid && !S_pla_reflow_fifo_alful)
                        begin
                            S_slice_id_current <= S_slice_id_current + 15'd1;
                        end
                    else
                        begin
                            S_slice_id_current <= S_slice_id_current;
                        end
                end
                C_REFLOW_READ  :///等待128个clk
                begin
                    if (S_read_state_cnt == 11'h7FF)   ///2帧左右  FF--3FRAME  FFF ---15帧读写冲突
                    begin
                        S_read_state_cnt <= S_read_state_cnt;   
                    end     
                    else 
                    begin
                        S_read_state_cnt <= S_read_state_cnt + 11'd1;  
                    end    
                end
                default :S_read_state_cnt <= 11'd0;
            endcase
        end
end

always @ (posedge I_pla_312m5_clk or posedge I_pla_rst)
begin
    if(I_pla_rst)
        begin
            S1_slice_id_current <= 15'd0;
        end
    else
        begin
            S1_slice_id_current <= S_slice_id_current;
        end
end

always @ (posedge I_pla_312m5_clk)
begin
    if(I_pla_slice_id_max >= (S_slice_id_current - 15'd1))
        begin
            S_pla_slice_id_depth_flg <= 1'b1;
        end
    else
        begin
            S_pla_slice_id_depth_flg <= 1'b0;
        end
end

always @ (posedge I_pla_312m5_clk or posedge I_pla_rst)
begin
    if(I_pla_rst)
        begin
        S_pla_reflow_id_wl <= 16'b0;
        end
    else
        begin
       if(S_pla_slice_id_depth_flg)
           S_pla_reflow_id_wl <= {1'b0,I_pla_slice_id_max} - ({1'b0,O_pla_slice_rd_id} - 16'd1);
       else
           S_pla_reflow_id_wl <= {1'b1,I_pla_slice_id_max} - ({1'b0,O_pla_slice_rd_id} - 16'd1);
        end
       
end

always @ (posedge I_pla_312m5_clk)
begin
    if(S_pla_reflow_id_wl > I_pla_slice_id_depth_set)
        begin
            S_pla_slice_id_depth_alful <= 1'b1;
        end
    else
        begin
            S_pla_slice_id_depth_alful <= 1'b0;
        end
end

always @ (posedge I_pla_312m5_clk or posedge I_pla_rst)
begin
    if(I_pla_rst)
    begin
        O_pla_reflow_rderr_cnt[31:16] <= 16'd0;
        S_pla_slice_loss_flg <= 1'b0; 
    end 
    else if(I_cnt_clear) 
    begin
        O_pla_reflow_rderr_cnt[31:16] <= 16'd0;
        S_pla_slice_loss_flg <= 1'b0; 
    end
    else if(!S_pla_slice_rd_resp_buf && I_pla_slice_rd_resp) 
    begin
        S_pla_slice_loss_flg <= 1'b0;
    end
    else if((S_reflow_state == C_REFLOW_CATCH) && (S1_reflow_catch_add && !S_slice_valid_ram_rd_data))
    begin
        S_pla_slice_loss_flg <= 1'b1;
        O_pla_reflow_rderr_cnt[31:16] <= O_pla_reflow_rderr_cnt[31:16] +16'd1;
    end
end



always @ (posedge I_pla_312m5_clk)
begin
    if(I_pla_rst)
        begin
            S_pla_slice_rd_req <= 1'd0;
            S_pla_slice_rd_id  <= 15'd0;
        end
    else
        begin
            case(S_reflow_state)
                C_REFLOW_IDLE  :       ///0
                begin
                    if(S_slice_current_valid && !S_pla_reflow_fifo_alful)
                        begin
                            S_pla_slice_rd_id  <= S1_slice_id_current;
                            S_pla_slice_rd_req <= 1'b1;
                        end
                    else
                        begin
                            S_pla_slice_rd_id  <= S_pla_slice_rd_id;
                            S_pla_slice_rd_req <= 1'd0;
                        end
                end
                C_REFLOW_CATCH :     ///1
                begin
                    if(!S_reflow_catch_add && S_slice_current_valid && !S_pla_reflow_fifo_alful)
                        begin
                            S_pla_slice_rd_id  <= S1_slice_id_current;
                            S_pla_slice_rd_req <= 1'b1;
                        end
                    else 
                        begin
                            S_pla_slice_rd_id  <= S_pla_slice_rd_id;
                            S_pla_slice_rd_req <= 1'd0;
                        end
                end
                default : 
                begin
                    S_pla_slice_rd_id  <= S_pla_slice_rd_id;
                    S_pla_slice_rd_req <= 1'd0;
                end
            endcase
        end
end

blk_sdpram_32768x1 U_blk_sdpram_32768x1
(
.I_porta_clk    (I_pla_312m5_clk           ),
.I_porta_addr   (S_slice_valid_ram_wr_addr ),
.I_porta_din    (S_slice_valid_ram_wr_data ),
.I_porta_wr     (S_slice_valid_ram_wr      ),
.I_portb_rst    (I_pla_rst                 ),
.I_portb_clk    (I_pla_312m5_clk           ),
.I_portb_addr   (S_slice_id_current        ),
.O_portb_dout   (S_slice_valid_ram_rd_data )
);

always @ (posedge I_pla_312m5_clk)
begin
    S_pla_slice_id_new_valid_buf <= I_pla_slice_id_new_valid;
end

always @ (posedge I_pla_312m5_clk)
begin
    S_pla_slice_rd_req_buf <= S_pla_slice_rd_req;
end

always @ (posedge I_pla_312m5_clk)
begin
    if(I_pla_slice_id_new_valid)
        begin
            S_slice_valid_ram_wr_addr <= I_pla_slice_id_new; 
            S_slice_valid_ram_wr_data <= 1'b1;  
            S_slice_valid_ram_wr      <= 1'd1;  
        end
    else if((S_pla_slice_rd_req && !S_pla_slice_rd_req_buf) || (S_pla_slice_id_new_valid_buf && S_pla_slice_rd_req_buf))
        begin
            S_slice_valid_ram_wr_addr <= S_pla_slice_rd_id; 
            S_slice_valid_ram_wr_data <= 1'b0;  
            S_slice_valid_ram_wr      <= 1'd1;
        end
    else
        begin
            S_slice_valid_ram_wr_addr <= 14'd0;
            S_slice_valid_ram_wr_data <= 7'd0;
            S_slice_valid_ram_wr      <= 1'd0;
        end
end

always @ (posedge I_pla_312m5_clk)
begin
    if(S_slice_valid_ram_wr)
        begin
            if(S_slice_id_current == S_slice_valid_ram_wr_addr)
                begin
                    S_slice_valid_ram_col      <= 1'b1;
                    S_slice_valid_ram_col_data <= S_slice_valid_ram_wr_data;
                end
            else
                begin
                    S_slice_valid_ram_col      <= 1'b0;
                    S_slice_valid_ram_col_data <= S_slice_valid_ram_col_data;
                end
        end
    else
        begin
            S_slice_valid_ram_col      <= 1'b0;
            S_slice_valid_ram_col_data <= S_slice_valid_ram_col_data;
        end
end

always @ (posedge I_pla_312m5_clk)
begin
    S_slice_valid_ram_col_buf <= S_slice_valid_ram_col;
end

always @ (posedge I_pla_312m5_clk)
begin
    if(I_pla_rst)
        begin
        	  S_slice_current_valid <= 1'b0  ;
        end
    else if(S_slice_valid_ram_col)
        begin
            S_slice_current_valid <= S_slice_valid_ram_col_data;
        end
    else
        begin
            S_slice_current_valid <= S_slice_valid_ram_rd_data ;
        end
end

always @ (posedge I_pla_312m5_clk)
begin
    if(I_pla_slice_rd_resp && !S_pla_slice_rd_resp_buf)
        begin
            S_pla_slice_data_rd <= 1'b1;
        end
    else if(&S_pla_slice_data_rd_cnt)
        begin
            S_pla_slice_data_rd <= 1'b0;
        end
end

always @ (posedge I_pla_312m5_clk)
begin
    if(I_pla_slice_rd_resp && !S_pla_slice_rd_resp_buf)
        begin
            S_pla_slice_data_rd_cnt <= 6'h0;
        end
    else if(&S_pla_slice_data_rd_cnt)
        begin
            S_pla_slice_data_rd_cnt <= S_pla_slice_data_rd_cnt;
        end
    else
        begin
            S_pla_slice_data_rd_cnt <= S_pla_slice_data_rd_cnt + 6'd1;
        end
end

always @ (posedge I_pla_312m5_clk)
begin
    S_pla_slice_data_rd_buf1 <= S_pla_slice_data_rd;
    S_pla_slice_data_rd_buf2 <= S_pla_slice_data_rd_buf1;
end

always @ (posedge I_pla_312m5_clk)
begin
    S_pla_slice_rdata_buf <= I_pla_slice_rdata;
end

always @ (posedge I_pla_312m5_clk)
begin
    if(I_pla_slice_rd_resp && !S_pla_slice_rd_resp_buf && S_pla_slice_loss_flg)
        begin
            S_pla_reflow_fifo_wdata <= 33'h1ffffffff;
            S_pla_reflow_fifo_wr    <= 1'b0;
        end
    else if(S_pla_slice_data_rd_buf2)
        begin
            S_pla_reflow_fifo_wdata <= {1'b0,I_pla_slice_rdata};
            S_pla_reflow_fifo_wr    <= 1'b1;
        end
    else
        begin
            S_pla_reflow_fifo_wdata <= 33'd0;
            S_pla_reflow_fifo_wr    <= 1'b0;
        end 
end

blk_com_fifo_512x33 U_blk_com_fifo_512x33(
.I_fifo_clk       (I_pla_312m5_clk          ),
.I_fifo_rst       (I_pla_rst                ),
.I_fifo_din       (S_pla_reflow_fifo_wdata  ),
.I_fifo_wr        (S_pla_reflow_fifo_wr     ),
.I_fifo_rd        (I_pla_reflow_fifo_rd     ),
.O_fifo_empty     (O_pla_reflow_fifo_empty  ),
.O_fifo_full      (),
.O_fifo_dout      (O_pla_reflow_fifo_rdata  ),
.O_fifo_usedw     (S_pla_reflow_fifo_usedw  )
);

always @ (posedge I_pla_312m5_clk)
begin
    S_pla_reflow_fifo_usedw_buf <= S_pla_reflow_fifo_usedw;
end

always @ (posedge I_pla_312m5_clk)
begin
    if(I_pla_rst)
        begin
            S_pla_reflow_fifo_alful <= 1'b0;
        end
    else if(|S_pla_reflow_fifo_usedw_buf[9:8])
        begin
            S_pla_reflow_fifo_alful <= 1'b1;
        end
    else
        begin
            S_pla_reflow_fifo_alful <= 1'b0;
        end
end

always @ (posedge I_pla_312m5_clk)
begin
    S1_pla_reflow_fifo_alful <= S_pla_reflow_fifo_alful;
end

assign O_pla_slice_rd_req         = S_pla_slice_rd_req ;
assign O_pla_slice_rd_id          = S_pla_slice_rd_id  ;
assign O_pla_slice_data_rd        = S_pla_slice_data_rd;
assign O_pla_slice_id_depth_alful = S_pla_slice_id_depth_alful;
assign O_pla_reflow_id_wl[15:0]   ={1'b0,S_pla_reflow_id_wl[14:0]};

assign O_pla_reflow_id_wl[31:16]  = {1'b0,S_pla_slice_rd_id} ;
assign O_pla_reflow_id_wl[47:32]  = {14'b0,S_reflow_state_next} ;

reg S1_pla_reflow_fifo_rd ;
reg [14:0] S_pla_reflow_rd_id ;


always @ (posedge I_pla_312m5_clk)
begin
    S_pla_reflow_fifo_rd      <= I_pla_reflow_fifo_rd       ;
    S1_pla_reflow_fifo_rd <= S_pla_reflow_fifo_rd && I_pla_reflow_fifo_rd;
    O1_pla_reflow_fifo_rdata   <= O_pla_reflow_fifo_rdata    ;
    if (I_pla_slice_rd_resp)
    begin
        S_pla_reflow_rd_id <=O_pla_slice_rd_id;
    end
end



//输出的//输入的SLICE ID顺序检测
pla_id_seq_chk U3_pla_id_seq_chk
(
.I_pla_312m5_clk         (I_pla_312m5_clk           ) ,
.I_pla_rst               (I_pla_rst                 ) ,
.I_pla_slice_id          (S_pla_reflow_rd_id        ) ,
.I_pla_slice_payload     (O1_pla_reflow_fifo_rdata[31:0] ) ,
.I_pla_slice_en          (S1_pla_reflow_fifo_rd      ) ,
.I_cnt_clear             (I_cnt_clear               ) ,
.O_slice_55D5_cnt        (O_reflow_55D5_cnt         ) , 
.O_slice_lose_cnt        (O_reflow_lose_cnt         ) ,
.O_slice_lose_reg        (O_reflow_lose_reg         ) 
);



endmodule
